#!/bin/bash
#
# for ctf
# 配られたlibcが手元に無くても無理やりバイナリを動かすことが出来るようにパッチを行う
#
# forked from https://gist.github.com/tachibana51/a89a748eaebc8b080eb0b46c35233e0d/raw/381232841e9d625ad759030d1ebe8fdf05775707/libc%2520changer

#### TODO ####
# miner libc version support
# backup original binary
# ubuntu version guessing

#### function ####
function usage {
cat >&2 <<EOS
usage: $0 <elf-file> [ubuntu-version] [glibc-version] [options]
or
usage: $0 <elf-file> [ubuntu-version] --local <libc-file> [options]
[options]
-h   | --help
  show help
-m32 | --mode-32bit
  patch 32bit libc
-l   | --local
  patch local libc
EOS
exit 1
}

function error {
  echo -e "\e[31m[Err]\e[m $1" >&2
  usage
  exit 1
}

function info {
  echo -e "\e[34m[i]\e[m $1"
}

function argc_check {
  if [ "${#args[*]}" -lt $1 ]; then
  error "missing arguments"
  fi
}

function check_patch {
  # check_patch <bin>
  if [ -z "`ldd $1 | grep `pwd` `" ]; then
    error "Patch failed !"
  fi
  info "Done !"
}

function get_libc_version {
  # get libc version from .rodata section
  # only support Ubuntu glibc
  if [ -z "`strings $1 | grep 'GNU C Library'`" ]; then
    error "invalid libc-file"
  fi
  glibc_version=`strings $1 | grep "GNU C Library" | sed -e "s/GNU C Library (Ubuntu GLIBC //g" | cut -d ")" -f 1`
  if [ -z "$glibc_version" ]; then
    error "cannot detect glibc version"
  fi
  echo $glibc_version
}

function get_libc_release_version {
  if [ -z "`strings $1 | grep 'GNU C Library'`" ]; then
    error "invalid libc-file"
  fi
  glibc_release_version=`strings $1 | grep "GNU C Library" | sed -e "s/GNU C Library (Ubuntu GLIBC //g" | cut -d ")" -f 1 | cut -d "-" -f 1`
  if [ -z "$glibc_release_version" ]; then
    error "cannot detect glibc release version"
  fi
  echo $glibc_release_version
}

function check_libc_bit_version {
  # check libc is 32bit or not
  if [ -n "$(file $1 | grep "32-bit")" ]; then
    M32=1
  else
    M32=
  fi
}

function patch {
  if [ "$M32" = 1 ]; then
    info "32bit patch mode"
    PACKAGES="libc6-i386 libc6-dbg-i386-cross"
    LIB_PATH="/lib32"
    DEBUG_PATH="/usr/i686-linux-gnu/lib/debug/lib/i386-linux-gnu"
  else
    info "64bit patch mode"
    PACKAGES="libc6-dbg"
    LIB_PATH="/lib/x86_64-linux-gnu"
    DEBUG_PATH="/usr/lib/debug/lib/x86_64-linux-gnu"
  fi
  sudo docker pull ubuntu:$ARG2
  sudo docker run --name tmp$ARG2 -i -t ubuntu:$ARG2 bash -c "apt update && apt -y install $PACKAGES"
  sudo docker cp tmp$ARG2:$LIB_PATH/ld-$ARG3.so .
  sudo docker cp tmp$ARG2:$LIB_PATH/libc-$ARG3.so "libc.so.6"
  mkdir -p ".debug"
  sudo docker cp tmp$ARG2:$DEBUG_PATH/libc-$ARG3.so ".debug/libc.so.6"
  mkdir -p .debug/$LIB_PATH
  sudo docker cp tmp$ARG2:$DEBUG_PATH/ld-$ARG3.so ".debug/ld-$ARG3.so"
  sudo docker rm tmp$ARG2
  patchelf --set-interpreter `pwd`/ld-$ARG3.so $ARG1
  patchelf --replace-needed  libc.so.6 "`pwd`/libc.so.6" $ARG1
  patchelf  --set-rpath `pwd` $ARG1
  check_patch $ARG1
}

function patch_local {
  info "local libc patch"
  GLIBC_VERSION=`get_libc_version $LOCAL_LIBC`
  GLIBC_RELEASE_VERSION=`get_libc_release_version $LOCAL_LIBC`
  info "glibc version detected"
  info $GLIBC_VERSION
  check_libc_bit_version $LOCAL_LIBC
  if [ "$M32" = 1 ]; then
    info "32bit patch mode"
    PACKAGES="libc6-i386 libc6-dbg-i386-cross"
    LIB_PATH="/lib32"
    DEBUG_PATH="/usr/i686-linux-gnu/lib/debug/lib/i386-linux-gnu"
  else
    info "64bit patch mode"
    PACKAGES="libc6-dbg"
    LIB_PATH="/lib/x86_64-linux-gnu"
    DEBUG_PATH="/usr/lib/debug/lib/x86_64-linux-gnu"
  fi
  sudo docker pull ubuntu:$ARG2
  if [ "$M32" = 1 ]; then
    sudo docker run --name tmp$ARG2 -i -t ubuntu:$ARG2 bash -c "apt update && apt -y --allow-downgrades install libc6-i386=$GLIBC_VERSION"
  else
    sudo docker run --name tmp$ARG2 -i -t ubuntu:$ARG2 bash -c "apt update && apt -y --allow-downgrades install libc6=$GLIBC_VERSION libc-dev-bin=$GLIBC_VERSION libc6-dev=$GLIBC_VERSION libc6-dbg=$GLIBC_VERSION"
  fi
  cp $LOCAL_LIBC "`pwd`/libc.so.6"
  sudo docker cp tmp$ARG2:$LIB_PATH/ld-$GLIBC_RELEASE_VERSION.so .
  mkdir -p ".debug"
  sudo docker cp tmp$ARG2:/usr/lib/debug/lib/x86_64-linux-gnu/libc-$GLIBC_RELEASE_VERSION.so ".debug/libc.so.6"
  mkdir -p .debug/$LIB_PATH
  sudo docker cp tmp$ARG2:/usr/lib/debug/lib/x86_64-linux-gnu/ld-$GLIBC_RELEASE_VERSION.so ".debug/ld-$GLIBC_RELEASE_VERSION.so"
  sudo docker rm tmp$ARG2
  patchelf --set-interpreter `pwd`/ld-$GLIBC_RELEASE_VERSION.so $ARG1
  patchelf --replace-needed  libc.so.6 "`pwd`/libc.so.6" $ARG1
  patchelf  --set-rpath `pwd` $ARG1
  check_patch $ARG1
}

#### init ####
# args
ARG1=
ARG2=
ARG3=
## 32bit mode
M32=
## local libc mode
LOCAL=
## local libc patch
LOCAL_LIBC=
# array of args
args=()
while [ "$#" != 0 ]; do
  case $1 in
    -h | --help           ) usage;;
    -m32 | --mode-32bit   ) M32=1;;
    -l | --local          ) shift; LOCAL_LIBC=$1 && LOCAL=1;;
    -* | --*              ) error "$1 : invalid option" ;;
    *                     ) args+=("$1");; # add args to array
  esac
  shift
done

if [ "$LOCAL" = 1 ] && [ -z "${LOCAL_LIBC}" ]; then
  error "libc-file is not specified."
fi

ARG1="${args[0]}"
ARG2="${args[1]}"
ARG3="${args[2]}"

#### main part ####
if [ "$LOCAL" = 1 ]; then
  # patch local libc
  argc_check 2
  patch_local
else
  argc_check 3
  patch
fi

